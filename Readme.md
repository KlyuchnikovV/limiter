# Limiter
Библитека позволяет создавать Rate Limiter для любых объектов имеющих уникальный идентификатор
Основан на алгоритме LeakBucket и работает следующим образом:
   1. поступает запрос на получение токена по id
      - если раньше не было запросов или количество запросов не превышено - отдаем токен и увеличивем счетчик
      - если превышен лимит - отдаем ошибку
   2. через некоторое время - `refillRate` срабатывает рутина для выделения новых токенов
      - для объектов с 0 токенов в работе - пропускаем
      - для остальных - уменьшаем количество токенов


Из идей для доработки
   1. нужна имплементация LRU + таймер для очистки давно не использующихся идентификаторов
   2. можно добавить один слой из дополнительных сервисов для синхронизации счетчиков между инстансами и записью в БД
      - раз в некоторое время Limiter запрашивает синхронизацию с сервисом/ами, который хранит набор счетчиков синхзронизированных с другими инстансами
      - сервис обновляет свою базу и отдает более новые данные Limiter (основыаваясь на метке времени)
      - Limiter принимает их, обновляет свои счетчики и продолжает локально считать до следующей синхронирзации

## Usage

```go
   // Создаем новый Limiter
   l, err := limiter.New(
      limiter.WithRefillRate(500*time.Millisecond),
      limiter.WithCapacity(3),
	)

   // Не забываем запустить и остановить его
   l.Start(ctx)
   defer l.Stop()

   // Получаем токены или ошибки
   token, err := l.Token(request.ID)
   if err != nil {
   ...
```

### Task:
Иногда в приложениях требуется задавать правила, ограничивающие частоту определенных действий. Например:
– Пользователь может отправлять не более 5 сообщений в секунду
– Один IP-адрес может отправлять не более 10000 запросов в минуту
– Юзер может иметь не более 3-х неудачных транзакций по карте в день


Механизмы, которые помогают создавать такие правила, называются Rate Limiter-ами.


Ваша задача - написать свой Rate Limiter.
– Решение должно быть написано на Golang; можно использовать только стандартную библиотеку;
– Добавьте небольшое readme с описанием работы решения и примером использования;
– Будет плюсом: подумайте о том, чтобы ваше решение могло использоваться в распределенных системах;


Проект должен быть залит на GitHub и оформлен как go module, с возможностью добавить его в проект через go get.
   Предоставляемое API остается на ваше усмотрение.
